{"meta":{"title":"Shane's Blog","subtitle":"Shane's Blog","description":"","author":"Shane Han","url":"http://shanehan.tech","root":"/"},"pages":[{"title":"about","date":"2020-03-16T12:14:47.000Z","updated":"2021-02-04T06:41:03.602Z","comments":true,"path":"about/index.html","permalink":"http://shanehan.tech/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-03-16T12:13:56.000Z","updated":"2021-02-04T06:41:03.602Z","comments":true,"path":"categories/index.html","permalink":"http://shanehan.tech/categories/index.html","excerpt":"","text":""},{"title":"contact","date":"2020-03-16T12:15:24.000Z","updated":"2021-02-04T06:41:03.602Z","comments":true,"path":"contact/index.html","permalink":"http://shanehan.tech/contact/index.html","excerpt":"","text":""},{"title":"friends","date":"2020-03-16T12:16:04.000Z","updated":"2021-02-04T06:41:03.602Z","comments":true,"path":"friends/index.html","permalink":"http://shanehan.tech/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-03-16T12:14:37.000Z","updated":"2021-02-04T06:41:03.614Z","comments":true,"path":"tags/index.html","permalink":"http://shanehan.tech/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hook","slug":"Hacking/Hook","date":"2021-02-04T13:48:56.000Z","updated":"2021-02-04T06:41:03.602Z","comments":true,"path":"posts/46aec6b/","link":"","permalink":"http://shanehan.tech/posts/46aec6b/","excerpt":"","text":"Hook是什么？Hook的作用如何进行Hook实例","categories":[{"name":"Hacking","slug":"Hacking","permalink":"http://shanehan.tech/categories/Hacking/"}],"tags":[{"name":"hacking","slug":"hacking","permalink":"http://shanehan.tech/tags/hacking/"}],"author":"ShaneHan"},{"title":"常见反汇编代码块","slug":"Hacking/常见反汇编代码块","date":"2021-02-03T17:26:26.000Z","updated":"2021-02-04T06:41:03.602Z","comments":true,"path":"posts/7eee2e60/","link":"","permalink":"http://shanehan.tech/posts/7eee2e60/","excerpt":"","text":"计算字符串长度 特征： repne scas byte ptr es:[edi] 代码块： 00406930 /$ 89FA mov edx, edi ;备份edi 00406932 |. 89C7 mov edi, eax ;edi里为存放的字符串 00406934 |. B9 FFFFFFFF mov ecx, -1 ;ecx放入-1，0xffff,最大值 00406939 |. 30C0 xor al, al ;al置0，字符串末尾就是0 0040693B |. F2:AE repne scas byte ptr es:[edi] ;从[edi]开始位置开始找al（遍历字符串），每循环一次cx-1 0040693D |. B8 FEFFFFFF mov eax, -2 ;由于cx末尾多减了一次，因此要用-2来减去得到真正的长度 00406942 |. 29C8 sub eax, ecx 00406944 |. 89D7 mov edi, edx ;恢复edi 代码块解释： repne命令： REPNE SCAS m8 Find AL, starting at ES:[(E)DI] 首先把地址给edi，然后ecx赋值为-1，al变为0（因为c的字符串都是以\\0结尾的），然后查找字符串的个数并放在ecx里，ecx取反得到个数，最后因为字符串的\\0也在其中，所以一般后面都有dec ecx。 进入函数，判断参数是否为0 特征： test xxx,xxx je xxx 实例： 注意：这是编译器进行速度优化（/O2）后的写法，不优化版是直接使用cmp对比","categories":[{"name":"Hacking","slug":"Hacking","permalink":"http://shanehan.tech/categories/Hacking/"}],"tags":[{"name":"hacking","slug":"hacking","permalink":"http://shanehan.tech/tags/hacking/"}],"author":"ShaneHan"},{"title":"结构体对齐","slug":"Hacking/结构体对齐","date":"2021-02-03T10:28:02.000Z","updated":"2021-02-04T06:41:03.602Z","comments":true,"path":"posts/6aac47f4/","link":"","permalink":"http://shanehan.tech/posts/6aac47f4/","excerpt":"","text":"1. 什么是结构体对齐结构体的大小（sizeof）不一定是结构体成员的大小（sizeof）的累加值。 2. 为什么要结构体对齐牺牲空间，优化效率的做法。32位机器中，访问32位的变量最快。 3. 如何结构体对齐 原则一：数据成员对齐规则：结构的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小的整数倍开始(比如int在32位机为４字节，则要从4的整数倍地址开始存储).参考案例一 原则二：结构体的总大小，也就是sizeof的结果，必须是其内部最大成员的整数倍，不足的要补齐。参考案例二 原则四：对齐参数如果比结构体成员的sizeof值小，该成员的偏移量应该以此值为准.也就是说，结构体成员的偏移量应该取二者的最小值。参考案例三 4. 案例分析 案例1： 结构体：struct Test { char a; int b; }; 结构体内存图: 案例2： 结构体：struct Test { int a; __int64 b; char c; }; 结构体内存图: 案例3： 结构体：struct Test { int a; __int64 b; char c; char d; }; 结构体内存图: 解析： VS2019默认对齐参数是8。 根据原则四，sizeof(__int64) = 对齐参数，所以偏移量=8，那么b的其实位置是(a + 4), 因为a占四个字节，再加4个字节，偏移量就是8了。 根据原则四，sizeof(char) &lt; 对齐参数，所以偏移量=1，所以c的其实位置是(b(8)后), 因为b占8个字节，偏移量已经超过1了。 根据原则四，sizeof(char) &lt; 对齐参数，所以偏移量=1，所以d的其实位置是(c(1)后)，因为c占1个字节，偏移量就是1了。 5. 补充 结构体定义的时候，应该按照数据类型由小到大的顺序进行书写。这样最节约内存。 对齐参数的设置(#pragma pack): 基本用法： #pragma pack(n) 结构体。。。 #pragma pack() n为字节对齐数，其取值为1、2、4、8，默认是8。 对齐参数如果比结构体成员的sizeof值小，该成员的偏移量应该以此值为准.也就是说，结构体成员的偏移量应该取二者的最小值 实例： 结构体结构源码：#pragma pack(n) struct Test { int a ; __int64 b ; char c ; }; #pragma pack() ``` 当n=8,即对齐参数为8 内存结构图： 解析： 根据原则四，sizeof(__int64) = 对齐参数，所以偏移量=8，那么b的其实位置是(a + 4), 因为a占四个字节，再加4个字节，偏移量就是8了。 根据原则四，sizeof(char) &lt; 对齐参数，所以偏移量=1，所以c的其实位置是(b(8)后), 因为b占8个字节，偏移量已经超过1了。 根据原则四，sizeof(char) &lt; 对齐参数，所以偏移量=1，所以d的其实位置是(c(1)后)，因为c占1个字节，偏移量就是1了。 当n=4,即对齐参数为4 内存结构图： 解析： 根据原则四，sizeof(__int64) &lt; 对齐参数4，所以偏移量=4，那么b的其实位置是(a(4)后), 因为a占四个字节，偏移量已经是4了。 根据原则四，sizeof(char) &lt; 对齐参数4，所以偏移量=1，所以c的其实位置是(b(8)后), 因为b占8个字节，偏移量已经超过1了。 根据原则四，sizeof(char) &lt; 对齐参数4，所以偏移量=1，所以d的其实位置是(c(1)后)，因为c占1个字节，偏移量就是1了。","categories":[{"name":"Hacking","slug":"Hacking","permalink":"http://shanehan.tech/categories/Hacking/"}],"tags":[{"name":"interview","slug":"interview","permalink":"http://shanehan.tech/tags/interview/"},{"name":"c/c++","slug":"c-c","permalink":"http://shanehan.tech/tags/c-c/"}],"author":"ShaneHan"},{"title":"C++反汇编特征记录","slug":"Hacking/C-反汇编","date":"2021-02-02T15:26:27.000Z","updated":"2021-02-04T06:41:03.602Z","comments":true,"path":"posts/8d38ffae/","link":"","permalink":"http://shanehan.tech/posts/8d38ffae/","excerpt":"","text":"1. 三目运算符1.1 无优化版： 特征：cmp xxx1,A jxx xxx3 xxx B xx jmp xxx4 xx C xx 实例：1.2 优化方案1： 特征：表达式1为简单比较，而表达式2和表达3两者的差值等于1；setne al 实例： 1.3 优化方案2： 特征： xxx1 == A? B:Ccmp xxx1, A mov xxx3， B mov xxx4, C cmovcc xxx3, xxx4 实例： 2. if…else…语句2.1 if单分支，无优化 特征：if（A） { B } cmp A jxx B_end B 实例： 2.1 if..else双分支，无优化 特征：if（A） { B } else {C} jxx ELSE_BEGIN；该地址为else语句块的首地址 IF_BEGIN： ……；if语句块内的执行代码 IF_END： jmp ELSE_END；跳转到else语句块的结束地址 ELSE_BEGIN： ……；else语句块内的执行代码 ELSE_END： 实例： 2.3 if..else if…else 多分支，无优化 特征： cmp；会影响标志位的指令 jxx ELSE_IF_BEGIN；跳转到下一条else if语句块的首地址 IF_BEGIN： ……；if语句块内的执行代码 IF_END： jmp END；跳转到多分支结构的结尾地址 ELSE_IF_BEGIN：；else if语句块的起始地址 ；可影响标志位的指令 jxx ELSE_BEGIN；跳转到else分支语句块的首地址 ……；else if语句块内的执行代码 IF_ELSE_END：；else if结尾处 jmp END；跳转到多分支结构的结尾地址 ELSE_BEGIN：；else语句块的起始地址 ……；else语句块内的执行代码 END：；多分支结构的结尾处 …… 实例： 2.4 if 多分支语句优化版： 特征： 使用test 代替cmp 尽量削减分支 实例： 3. Switch语句3.1 switch分支较少 特征：三条分支或者更少的情况下（default算一条分支）性能与if else性能类似。 mov reg, mem；取出switch中考察的变量 cmp 或其他影响标志位的指令 jxx xxxx；跳转到对应case语句块的首地址处 cmp 或其他影响标志位的指令 jxx xxxx cmp 或其他影响标志位的指令 jxx xxxx jmp END；跳转到switch的结尾地址处 ……；case语句块的首地址 jmp END；case语句块结束，有break则产生这个jmp ……；case语句块的首地址 jmp END；case语句块的结束，有break则产生这个jmp ……；case语句块的首地址 jmp END；case语句块结束，有break则产生这个jmp END：；switch结尾 实例： 注意： 这种情况下switch和if…else if…else的区别。 3.2 switch分支较多，case后的值连续 特征： 生产一张大表，按case值大小顺序存储case后的语句块对应的地址。 switch值-最小的case值，就可以得到case后的语句块地址在表中的偏移，从而快速进入对应的case处理 实例 3.3 switch分支较多，case后的值连续，但是有少量空缺 特征： 还是生产一张大表，按case值大小顺序存储各个case后的语句块地址 case空缺处用default语句块填充。 实例： 3.4 switch分支较多，case后的值连续，但是有大量空缺 特征 生成两张表，表一：存储各个case分支处理的地址；表二：按case值顺序存储各个case值对应的处理函数在地址表中的序号。 switch值-最小的case值，就可以得到case后的处理函数地址在表一的偏移，再通过这个序号，可以在表二中快速找到对应的case分支处理。 实例： 3.5 总结 何时生成大表？ 分支较多，且case的值连续。 case分支顺序打乱，观察顺序是否会影响生成大表？ 观察值较大时是否生成大表？值大小不影响，只要连续就行 大表空缺位置的处理？填充default分支 何时生成小表？ case值连续，但是中间空缺较多，比如case值是1,5,6,7 14 Case值不连续？ switch变得与if-else差不多。","categories":[{"name":"Hacking","slug":"Hacking","permalink":"http://shanehan.tech/categories/Hacking/"}],"tags":[{"name":"Hacking","slug":"Hacking","permalink":"http://shanehan.tech/tags/Hacking/"},{"name":"C/C++","slug":"C-C","permalink":"http://shanehan.tech/tags/C-C/"}],"author":"ShaneHan"},{"title":"如何创建一个Task","slug":"Apollo/如何创建一个Task","date":"2020-06-11T13:33:55.000Z","updated":"2021-02-04T06:41:03.602Z","comments":true,"path":"posts/3add8ad6/","link":"","permalink":"http://shanehan.tech/posts/3add8ad6/","excerpt":"","text":"Step 1: 创建task需要的相关文件 在planning/tasks中的decider或者optimizer中创建对应的task目录，如abreast_decider. 新建源文件，如abreast_decider.cc和abreast_decider.h abreast_decider.cc模板: #include &quot;modules/planning/tasks/deciders/abreast_decider/abreast_decider.h&quot; namespace apollo { namespace planning { using apollo::common::Status; AbreastDecider::AbreastDecider(const TaskConfig &amp;config) : Decider(config) { SetName(&quot;AbreastDecider&quot;); } Status AbreastDecider::Process( Frame *const frame, ReferenceLineInfo *const reference_line_info) { return Status::OK(); } } } ``` --- abreast_decider.h模板: ``` #ifndef __REINFORCEMENT_LEARNING_DECIDER_H #define __REINFORCEMENT_LEARNING_DECIDER_H #include &quot;modules/planning/proto/decider_config.pb.h&quot; #include &quot;modules/planning/tasks/deciders/decider.h&quot; #include &quot;modules/planning/common/planning_gflags.h&quot; namespace apollo { namespace planning { class AbreastDecider : public Decider { public: explicit AbreastDecider(const TaskConfig &amp;config); private: common::Status Process(Frame *frame, ReferenceLineInfo *reference_line_info) override; }; } // namespace planning } // namespace apollo #endif ``` 新建BUILD文件，用于Bazel编译使用。如下 load(&quot;//tools:cpplint.bzl&quot;, &quot;cpplint&quot;) package(default_visibility = [&quot;//visibility:public&quot;]) cc_library( name = &quot;abreast_decider&quot;, srcs = [ &quot;abreast_decider.cc&quot;, ], hdrs = [ &quot;abreast_decider.h&quot;, ], copts = [&quot;-DMODULE_NAME=\\\\\\&quot;planning\\\\\\&quot;&quot;], deps = [ &quot;//modules/planning/tasks/deciders:decider&quot;, &quot;//modules/planning/common:planning_gflags&quot;, &quot;//modules/planning/common:reference_line_info&quot;, ], ) cpplint() Step 2: 注册task 在task_factory.cc中保护对应的头文件，如： #include &quot;modules/planning/tasks/deciders/abreast_decider/abreast_decider.h&quot; 注册task进task_factory中。其中修改ABREAST_DECIDER——这是你在planning conf里面调用的名字；AbreastDecider是在你的task源文件中定义的decider类的名字。 task_factory_.Register(TaskConfig::ABREAST_DECIDER, [](const TaskConfig&amp; config) -&gt; Task* { return new AbreastDecider(config); }); 给task_factory 添加依赖。修改modules/planning/tasks/BUILD，给cc_library/deps添加abreast_decider的依赖。如下 cc_library( name = &quot;task_factory&quot;, srcs = [ &quot;task_factory.cc&quot;, ], hdrs = [ &quot;task_factory.h&quot;, ], copts = [&quot;-DMODULE_NAME=\\\\\\&quot;planning\\\\\\&quot;&quot;], deps = [ &quot;:task&quot;, ...省略... &quot;//modules/planning/tasks/deciders/abreast_decider:abreast_decider&quot;, ...省略... ], ) 添加task config 在modules/planning/proto中创建abreast_decider_config.proto文件。如： syntax = &quot;proto2&quot;; package apollo.planning; message AbreastDeciderConfig { optional double abreast_time = 1; optional double lateral_area = 2; optional double longitudinal_area = 3; } 生成proto_library。在modules/planning/proto/BUILD中生成对应的proto_library.如： proto_library( name = &quot;abreast_decider_config_lib&quot;, srcs = [ &quot;abreast_decider.proto&quot;, ], ) 在proto_library中添加依赖。如下： proto_library( name = &quot;planning_config_proto_lib&quot;, srcs = [ &quot;planning_config.proto&quot;, ], deps = [ ...省略... &quot;:abreast_decider_config_lib&quot; ], ) 在planning_config.pb.txt中添加默认配置。 default_task_config: { task_type: ABREAST_DECIDER abreast_decider_config { abreast_time: 60.0 lateral_area: 2.0 longitudinal_area: 10.0 } } 在modules/planning/proto/planning_config.proto中添加相关的task信息 import &quot;modules/planning/proto/abreast_decider_config.proto&quot; 添加TaskType： ABREAST_DECIDER = 22 添加task_config： AbreastDeciderConfig abreast_decider_config = 18;","categories":[],"tags":[],"author":"ShaneHan"},{"title":"Hexo博客搭建和自动化部署","slug":"Hexo/Hexo博客搭建和自动化部署","date":"2020-03-17T09:05:20.000Z","updated":"2021-02-04T06:41:03.602Z","comments":true,"path":"posts/96b0a1fd/","link":"","permalink":"http://shanehan.tech/posts/96b0a1fd/","excerpt":"","text":"Hexo博客搭建和自动化部署Hexo 是一款快速、简洁且高效的博客框架. 常用插件 hexo-asset-image 解决问题： hexo博客图片的问题在于，markdown文章使用的图片路径和hexo博客发布时的图片路径不一致。通常我们使用markdown书写博客时, 采用的方式是使用 格式插入图片，我们希望在生成博客时，可以将图片转换成正确的格式。 安装： npm install https://github.com/7ym0n/hexo-asset-image --sa 配置：只需要在_config.yml 中配置 post_asset_folder 为 true 即可。 abbrlink 解决问题： 解决hexo博客链接很长的问题。 常用工具 网站配色: 漂亮炫酷的配色网站 TODO 双语bolg: 添加中英文切换按钮 自动化部署 github 和服务器同步博客文件工具及教程 webhook 部署hexo ubuntu 自启服务","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://shanehan.tech/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://shanehan.tech/tags/hexo/"}],"author":"ShaneHan"}]}